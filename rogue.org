#+TITLE: Rogue-Like Game in C++17
#+AUTHOR: Neel Raiyani
#+EMAIL: nraiyani at gmail dot com
#+LANGUAGE: en
#+SETUPFILE: docs\theme.org
#+EXPORT_FILE_NAME: docs\index.html
#+STARTUP: showall noindent

* Setup
** Environment Setup
*** Tools of the trade:
	Below is listing of tools I am using
	|---------------------+------------------------------+---------|
	|                 <r> | <l>                          |     <r> |
	|                Tool | Name                         | Version |
	|---------------------+------------------------------+---------|
	|              Editor | [[https://code.visualstudio.com/][VSCode]]                       |  1.38.1 |
	|       C++ Toolchain | [[https://visualstudio.microsoft.com/vs/][Visual Studio 2019 Community]] |  16.3.2 |
	| C++ Build Generator | [[https://cmake.org/][CMake]]                        |  3.15.1 |
	| C++ Package Manager | [[https://github.com/Microsoft/vcpkg][vcpkg]]                        | 2019.09 |
	|     Version Control | [[https://git-scm.com/][git]]                          |  2.23.0 |
	|---------------------+------------------------------+---------|

*** Editor Configuration
	Following extensions are installed in VSCode
	- [[https://marketplace.visualstudio.com/items?itemName=CoenraadS.bracket-pair-colorizer-2][Bracket Pair Colorizer 2]]
	- [[https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools][C/C++]]
	- [[https://marketplace.visualstudio.com/items?itemName=maddouri.cmake-tools-helper][CMake Tools Helper]]
	  This will installed 2 other extensions
	  - [[https://marketplace.visualstudio.com/items?itemName=vector-of-bool.cmake-tools][CMake Tools]]
	  - [[https://marketplace.visualstudio.com/items?itemName=twxs.cmake][CMake for Visual Studio Code]]

*** vcpkg configuration
	- Add Environment Variable called VCPKG_ROOT and point it to location of your vcpkg installation directory.
	  For me this is '~D:\Projects\CPP\.packages\vcpkg~'.
	- Add Environment Variable called ~VCPKG_DEFAULT_TRIPLET~ and set it equal to ~x64-<system name>~.
	  Again for me this is '~x64-Windows~'.

** Project Setup
*** Folder Structure
	This is how i've structured the project folders. The name of the Root Folder doesn't matter, in my case it's called ~roguelike~.
	#+begin_src markdown
	  \          # Root folder
	  \build\    # where cmake will put all build generated files
	  \docs\     # documentation folder, where this index.html file is located
	  \src\      # where all the source files will go
	  \external\ # any 3rd party libraries we can't get via vcpkg will go here
	#+end_src
*** ~\.gitignore~ file
	We'll be ignore following files and folders. No point in adding these to our git repo.
	#+name: .gitignore
	#+begin_src markdown -n 
	  # cmake build directory
	  build/
	  CMakeCache.txt
	  CMakeFiles/

	  # vscode and visual studio specific
	  .vscode/
	  .vs/

	  # org-mode temp files
	  ./*.html
	  backups/
	  .#*.org
	#+end_src
*** CMake configuration
	After you create the CMakeList.txt file below, VSCode should recognize this folder as being CMake project.
	It will ask you to choose the toolchain with which to envoke the build process.
	CppTools extension in VSCode comes with Ninja as it's build engine, which CMake Tools extension automatically uses.
	If you try to run this project from command line, you'll need to add additional parameters telling CMake to generate a VS Solution, instead of Ninja. Or you can install Ninja system-wide. Exercise for the reader.
   
	- ~\CMakeLists.txt~
	  This in the root of our project. We define basic things about how cmake should do things.
	  Lines 3 to 6 tell cmake to use vcpkg toolchain file.
	#+name: CMakeLists.txt
	#+begin_src cmake -n
	  cmake_minimum_required(VERSION 3.15.0)

	  if(DEFINED ENV{VCPKG_ROOT} AND NOT DEFINED CMAKE_TOOLCHAIN_FILE)
		set(CMAKE_TOOLCHAIN_FILE "$ENV{VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake"
			CACHE STRING "")
	  endif()

	  project(rogue
			  LANGUAGES CXX 
			  VERSION 0.1.0)

	  set(CMAKE_CXX_STANDARD_REQUIRED ON)
	  set(EXECUTABLE_OUTPUT_PATH "${CMAKE_BINARY_DIR}/bin/")

	  add_subdirectory(src)
	#+end_src
	- ~\src\CMakeLists.txt~
	  This is in our src directory, here we tell cmake that we want output executable to be named rogue.exe.
	  We also tell it we want to use C++17 standard. This doesn't actually work with MSVC.
	  So... we have to explictly tell cmake to pass some parameters to MSVC compiler
	#+name: src\CMakeLists.txt
	#+begin_src cmake -n
	  find_package(fmt REQUIRED)

	  add_executable(rogue main.cpp)

	  target_compile_features(rogue PRIVATE cxx_std_17)

	  target_compile_options(rogue
							 PRIVATE 
							 $<$<CXX_COMPILER_ID:MSVC>:/W3 /permissive- /Zc:__cplusplus /std:c++17>)

	  target_compile_definitions(rogue
								 PRIVATE
								 $<$<CONFIG:Debug>:DEBUG _DEBUG>)

	  target_link_libraries(rogue PRIVATE fmt::fmt)
	#+end_src
*** CMake Hello World test file
	Time to test if the Setup is done properly.
	
	First, let's install ~fmtlib~ from vcpkg. ~fmtlib~ is a string formatting library, much easier to use than standard ~std::cout~.
	We will get vcpkg to download and build it.
	#+begin_src sh -n
  vcpkg install fmt
	#+end_src

	Next, let's create a simple ~\src\main.cpp~ file, to test build configuration.
	We will use ~std::chrono~ to get current timepoint, and print that with ~fmt::print~.
	#+name src\main.cpp
	#+begin_src cpp -n
  #include <iostream>
  #include <fmt/core.h>
  #include <chrono>
  #include <string>

  int main()
  {
	auto tp = std::chrono::system_clock::now();
	auto now_c = std::chrono::system_clock::to_time_t(tp);
	fmt::print("Hello, World! {}", now_c);
  }
	#+end_src

	If all of the above is done properly the file below should compile and generate an executable.
	In VSCode you can start the build process, by click on =Build= in the ~status bar~ or pressing =F7= key.
	It can be executed by calling ~\build\src\rogue.exe~ from the project root folder.

*** libTCOD Configuration
	The above Setup section looks like a lot of work just to get "Hello, World" printed on to console. We could have avoided all of that hassle by not using cmake. But I want to learn cmake, so...

	I going to try to closely follow the tutorials presented at [[http://www.rogueliketutorials.com/tutorials/tcod/][Roguelike Tutorials]] and the variant [[https://tomassedovic.github.io/roguelike-tutorial/index.html][Roguelike Tutorials in Rust]]. We will be using the same library that it is using. Except instead of Python, we'll be in C++.
	However, given that we are going to use C++, there is a some setup overhead involved. Specifically, to get ~libtcod~ working and linking with our game.

	We have two options here. 
	- Get the source code and build the library ourselves.
	- Download pre-built package, and use those. 
	Place to go for either option is [[https://github.com/libtcod/libtcod][libtcod github repo]]

	I am going to go with pre-built version. Author of libtcod uses VS2015, which is ABI compatible with our VS2019 setup. So everything should just work. :fingers-crossed:
	Having downloaded [[https://github.com/libtcod/libtcod/releases/download/1.14.0/libtcod-1.14.0-x86_64-msvc.zip][libtcod 1.14 x64]]. Now we have to tell cmake where to go to find this library.
	I've extracted the contents of the zip file into ~\external\libtcod-1.14.0-x86_64-msvc~ folder. I've also added the folder to our gitignore list. We don't need everything in the archive only some parts.
	#+name: .gitignore
	#+begin_src markdown -n 15
  # the prebuilt libtcod files
  external/libtcod-1.14.0-x86_64-msvc/
	#+end_src
   
	Now we create a ~external\CMakeLists.txt~ file, this will tell cmake to let us consume this library from our code.
	We also put in a custom target, so that cmake will copy the .dll files into same directory as our executable. This way when we run our game, we don't get missing dll errors.
	#+name: external/CMakeLists.txt
	#+begin_src cmake -n
  # Add directories for libtcod
  set(LIBTCOD_DIR "${CMAKE_CURRENT_SOURCE_DIR}/libtcod-1.14.0-x86_64-msvc")

  set(LIBTCOD_INCLUDE "${LIBTCOD_DIR}/include/" CACHE PATH "Path to Libtcod Include")
  find_library(LIBTCOD_LIB libtcod ${LIBTCOD_DIR})

  add_custom_target(libtcod_bins
	COMMAND ${CMAKE_COMMAND} -E copy ${LIBTCOD_DIR}/libtcod.dll ${EXECUTABLE_OUTPUT_PATH}
	COMMAND ${CMAKE_COMMAND} -E copy ${LIBTCOD_DIR}/sdl2.dll ${EXECUTABLE_OUTPUT_PATH}
  )
	#+end_src
   
	Next, we modify our root ~CMakeLists.txt~, by adding ~add_subdirectory(external)~ to line before ~src~ directory is added.
	#+name: \CMakeLists.txt
	#+begin_src cmake -n 15
  add_subdirectory(external)
  add_subdirectory(src)
	#+end_src

	Lastly, we need to tell ~src\CMakeLists.txt~ to consume =libtcod=.
	#+name: src\CMakeLists.txt
	#+begin_src cmake -n 17
  target_include_directories(rogue PRIVATE ${LIBTCOD_INCLUDE})

  target_link_libraries(rogue PRIVATE fmt::fmt ${LIBTCOD_LIB})

  add_dependencies(rogue libtcod_bins)
	#+end_src

*** libTCOD Test file/executable
	Phew, so much CMAKE, we can finally see if all this setup is working.
	Let's modify our ~main.cpp~ to actually call libtcod
	#+name: main.cpp
	#+begin_src cpp -n
  #include <libtcod.hpp>

  int main()
  {
	TCODConsole::initRoot(80,50,"libtcod C++ tutorial",false, TCOD_RENDERER_SDL2);
	while ( !TCODConsole::isWindowClosed() ) {
	  TCOD_key_t key;
	  TCODSystem::checkForEvent(TCOD_EVENT_KEY_PRESS,&key,NULL);
	  TCODConsole::root->clear();
	  TCODConsole::root->putChar(40,25,'@');
	  TCODConsole::flush();
	}
	return 0;
  }
	#+end_src
	Here we are starting a TCODConsole, telling it explicitly to use SDL2. By default, the console will try to use SDL1, we don't want that.
	
	Hit build in VSCode, and it should generate ~rogue.exe~ in ~\build\bin~ directory, as well, copy the necessary libtcod dlls there.
	Running the executable, should open a window, with =@= in the middle of the window. Program does nothing else, for now...

*** A word on debugging with VSCode
	If you launch the application from any other directory other than \build\bin.
	And that "working directory" does not have the required data files, then application will not function properly.
	Following steps must be taken to get VSCode to launch debugging session properly.

[[https://github.com/Roy-Fokker/roguelike/tree/f9022f035ffb9e36ed6bdbbfad7e1303180249e4][Git Repo on 2019/10/06]]

* Drawing Player and Moving around
  *NOTE*: A word about the code and explainations, I won't be explaining every feature of C++ being used. 
  Perhaps, you are new to C++, but not new to programming then code should make sense to you.
  For any keywords, or classes from Standard Library that are new for you, I suggest looking it up in [[https://www.cppreference.com][Cpp Reference]]. 
  In general, I write C++ heavily influenced by [[http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines][C++ Core Guidelines]], code is formatted in [[https://en.wikipedia.org/wiki/Indentation_style#Allman_style][Allman style]]. 
  You might prefer some other styles/means, feel free to write in a way that is comfortable to you.

  From here on out, we are going to focus on our rogue game. Rest of this document follows similar structure as Python RogueLike Tutorials.
  There will be some differences, as C++ and Python are different languages, and operate with different mindsets.

  Looking at the [[http://www.rogueliketutorials.com/tutorials/tcod/][Roguelike Tutorials]] - Part 1, we've already written some of the Console Startup code in our ~main.cpp~.
  For this section, our goals are:
  - handle input, so '=@=' moves around
  - catch when '=ESC=' key is pressed to exit from game
  - catch when '=Alt+Enter=' key combination is pressed to toggle fullscreen mode
  - load a custom font for displaying characters on screen.
  Below each code block is brief description of what is being done. \\
  All of this will be done by modifying our ~src\main.cpp~. 
** ~src\main.cpp~
   #+name: src\main.cpp
   #+begin_src cpp -n
  #include <libtcod.hpp>
  #include <string>
  #include <utility>
  #include <cassert>
  #include <any>
   #+end_src
   1. This is the main header for =libtcod=
   2. C++ String header, pulling in classes/functions to handled strings.
   3. C++ Utlity header, to pull in =std::pair= class
   4. C Assert header, pulls in =assert= macro, useful for debugging
   5. C++ Any header, to pull in =std::any= class

   #+name: src\main.cpp
   #+begin_src cpp -n 7
  using namespace std::literals;

  using console = TCODConsole;
   #+end_src
   7. [@7] Import namespace =std::literals=, so we can use string literals for text. e.g "xxx"sv
   9. [@9] I don't want to constantly be typing =TCODxxxx=, so we setup ~console~ as an Alias for =TCODConsole=, with help of ~using~ statement.

   #+name: src\main.cpp
   #+begin_src cpp -n 11
  enum class actions
  {
   do_nothing,
   exit,
   move,
   fullscreen_toggle,
  };

  using move_dir = std::pair<int, int>;
   #+end_src

   11. [@11] These are actions we will be performing in this game. List will eventually get larger. \\
	   Hopefully, most of the Enumeration values are self explaining.
   19. [@19] Define =move_dir= (move direction) as simple pair of integers, using ~std::pair~. \\
	   ~std::pair~ has two members, ~.first~ and ~.second~, we will use them for ~x~ and ~y~ respectively.

   #+name: src\main.cpp
   #+begin_src cpp -n 21
  auto handle_input() -> std::pair<actions, std::any>
  {
	using key_code = TCOD_keycode_t;
	auto key = console::checkForKeypress();

	switch (key.vk)
	{
	  case key_code::TCODK_ESCAPE:
		return {actions::exit, 0};
	  case key_code::TCODK_UP:
		return {actions::move, move_dir{0, -1}};
	  case key_code::TCODK_DOWN:
		return {actions::move, move_dir{0, 1}};
	  case key_code::TCODK_LEFT:
		return {actions::move, move_dir{-1, 0}};
	  case key_code::TCODK_RIGHT:
		return {actions::move, move_dir{1, 0}};
	  case key_code::TCODK_ENTER:
	  {
		if (key.lalt or key.ralt)
		{
		  return {actions::fullscreen_toggle, 0};
		}
		break;
	  }
	}

	return {}; // will automatically return actions::do_nothing
  }
   #+end_src
   21. [@21] This function handles our input. I am using "Trailing Return Type" format for function signature. \\
	   For each key press we are interested in, this function will translate it into our actions enumeration. \\
	   Additionally, since we are returning a pair of "things", 2nd value can be anything (std::any).
   23. [@23] ~libtcod~ is actually a C library. So it tends to define enums in a C-style. \\
	   Generally, in C++ it's recommended to use strong enum. Here I am just aliasing it to help with intellisense in VSCode.

   #+name: src\main.cpp
   #+begin_src cpp -n 51
  int main()
  {
	constexpr auto window_width  = 100,
				   window_height = 56;
	constexpr auto window_title  = "Rogue C++ Tutorial - Part 1"sv,
				   font_file     = "arial10x10.png"sv;

	console::setCustomFont(font_file.data(), TCOD_FONT_TYPE_GREYSCALE | TCOD_FONT_LAYOUT_TCOD);

	console::initRoot(window_width, window_height,
					  window_title.data(),
					  false, TCOD_RENDERER_SDL2);
	atexit(TCOD_quit); // the C-Runtime will automatically call this function.
   #+end_src
   53. [@53] Define width, height and title to use with console window. \\ 
	   These are constexpr they'll get evaluated at compile time. \\
   55. [@55] ~"xxx"sv~ means create this as a =std::string_view=, more type safe than using =char[]= or =char*=.
   56. This is the font file we will be using. It will be placed in ~build\bin\~ directory by CMake.
   58. [@58] Tell libTcod that we want to use a custom font file.
   60. [@60] Use the variables we defined above to create and launch root console.
   62. [@62] We have to explicitly specify that we want to use SDL2, we have other options as well i.e GLSL, OPENGL, OPENGL2.
   63. [@63] Make sure that we call ~TCOD_quit()~ when the application exits.

   #+name: src\main.cpp
   #+begin_src cpp -n 65
	auto game_console = console(window_width, window_height);
   #+end_src
   65. [@65] Get an instance of console. Instead of using root console.

   #+name: src\main.cpp
   #+begin_src cpp -n 67
	bool exit_game = false;
	int player_x = window_width / 2, 
		player_y = window_height / 2;
	while (not (console::isWindowClosed() or exit_game))
	{
   #+end_src
   67. [@67] Some game specific variables. \\
	   If ~exit_game~ is true, we will exit the loop \\
	   ~player_x~ and ~player_y~ will control where the "@" character will be drawn.
   70. [@70] C++ defines =not=, =or=, =and=, et.al as [[https://en.cppreference.com/w/cpp/language/operator_alternative][keywords]]. \\
	   I prefer to use these in =if= statements, and generally where similar type of conditions need to be checked. \\
	   Keep in mind VSCode's C++ parser does not understand these keywords. This is a bug in [[https://github.com/microsoft/vscode-cpptools/issues/1589][VSCode]].

   #+name: src\main.cpp
   #+begin_src cpp -n 72
	  auto action = handle_input();
	  switch (action.first)
	  {
		case actions::do_nothing:
		  break;
		case actions::exit:
		  exit_game = true;
		  break;
		case actions::move:
		{
		  auto dir = std::any_cast<move_dir>(action.second);
		  player_x += dir.first;
		  player_y += dir.second;
		  break;
		}
		case actions::fullscreen_toggle:
		{
		  game_console.setFullscreen(not game_console.isFullscreen());
		  break;
		}
		default:
		  assert(false); // We forgot to handle some action. DEBUG!
	  }
   #+end_src
   72. [@72] Call our input handling function, that we defined on line 21.
   73. Simple =switch= on =action=. ~.first~ here reads the 1st value of the pair that we returned from =handle_input=.
   82. [@82] Because 2nd value of our pair is a =std::any= we have to use ~std::any_cast~ to go back to the
	   type we put in, in this case we put in ~move_dir~.
   83. Update the value of player position using first and second value of the pair we got from line 82.
   89. [@89] Toggle fullscreen mode, by simple negation of current window state.

   #+name: src\main.cpp
   #+begin_src cpp -n 96
	  game_console.clear();
	  game_console.setDefaultForeground(TCODColor::white);
	  game_console.putChar(player_x, player_y, '@');
	
	  console::blit(&game_console, 0, 0, window_width, window_height, 
					console::root, 0, 0);
	  console::flush();
	}

	return 0;
  }
   #+end_src
   96. [@96] Clear the console, so we have clean canvas
   97. Set foreground color to White.
   98. Update the position of "@" using ~player_x~ and ~player_y~.
   100. [@100] Blit our ~game_console~ on to ~root~ console.
   102. [@102] Flush whole thing to screen.

** ~external\CMakeLists.txt~
   At present we don't have any font texture in our ~build\bin~ folder. So like we did in =Setup= section we are going to tell CMake to copy that file over.
   We'll do this by appending the copy command to our list of commands in ~add_custom_target~ function.
   #+name: external\CMakeLists.txt
   #+begin_src cmake -n 7
  add_custom_target(LIBTCOD_BINS
	  COMMAND ${CMAKE_COMMAND} -E copy ${LIBTCOD_DIR}/libtcod.dll ${EXECUTABLE_OUTPUT_PATH}
	  COMMAND ${CMAKE_COMMAND} -E copy ${LIBTCOD_DIR}/sdl2.dll ${EXECUTABLE_OUTPUT_PATH}
	  COMMAND ${CMAKE_COMMAND} -E copy ${LIBTCOD_DIR}/data/fonts/arial10x10.png ${EXECUTABLE_OUTPUT_PATH}
  )
   #+end_src

[[https://github.com/Roy-Fokker/roguelike/tree/e0ad47e8d2df92b0b9c54d36b53a044c927f7312][Git Repo on 2019/10/07]]
* Entity System
  
* Generating a Dungeon

* Field of View

* Placing Enemies

* Combat Loop

* User Interface

* Items and Inventory

* Equiping Items

* Weapons and Targetting

* Saving and Loading Game State

* Dungeon Delving

* Difficulty Curve

